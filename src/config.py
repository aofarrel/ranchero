import os
import csv
import sys
import json
import logging
import polars as pl
import tqdm
import yaml
from typing import Literal, TypedDict
loggerhead = {10: "DEBUG", 20: "INFO", 30: "WARN", 40: "ERROR"}

# This takes a lot of inspiration from how polars handles configuration,
# but I'm still not happy with it (nor does it actually enforce types).

if sys.version_info >= (3, 10):
	from typing import TypeAlias
else:
	from typing_extensions import TypeAlias

# valid options for dupe_index_handling
DupeIndexOptions: TypeAlias = Literal[
	"error",
	"verbose_error", 
	"warn",
	"verbose_warn",
	"silent",
	"allow",
	"dropall",
	"keep_most_data"
]

# valid options for host_info_handling
HostInfoOptions: TypeAlias = Literal[
	"dictionary",
	"drop",
	"options"
]

class ConfigParameters(TypedDict):
	read_file: dict
	check_index: bool
	dupe_index_handling: DupeIndexOptions
	force_SRR_ERR_DRR_run_index: bool
	force_SAMN_SAME_SAMD_sample_index: bool
	host_info_handling: HostInfoOptions
	indicator_column: str
	intermediate_files: bool
	loglevel: int
	mycobacterial_mode: bool
	paired_illumina_only: bool
	polars_normalize: bool
	rm_phages: bool
	unwanted: bool

	# not sure if this is how I want to handle this...
	taxoncore_ruleset: None

class ReadFileParameters(TypedDict):
	auto_cast_types: bool
	auto_parse_dates: bool
	auto_rancheroize: bool
	auto_standardize: bool
	ignore_polars_read_errors: bool

class RancheroConfig:

	# this isn't a replacement for proper type checking
	def is_in_ReadFileParameters(self, key) -> bool:
		return key in ReadFileParameters.__annotations__
	def is_in_ConfigParameters(self, key) -> bool:
		return key in ConfigParameters.__annotations__

	def print_config_raw(self) -> None:
		print(self.__dict__)

	def print_config(self) -> None:
		this_config = self.__dict__.copy()
		print("Configuration:")
		for keys, values in this_config.items():
			if keys == "unwanted":
				for keys, values in self.unwanted.items():
					print(f"* Unwanted {keys}: {values}")
			elif keys == 'read_file':
				print("File read options:")
				for k, v in self.read_file.items():
					print(f"--> {k}: {v}")
			elif keys == 'taxoncore_ruleset' and this_config['taxoncore_ruleset'] is not None:
				print(f"* {keys}: Initialized with {len(this_config['taxoncore_ruleset'])} values")
			elif keys == 'loglevel':
				print(f"* {keys}: {values} ({loggerhead[values]})")
			elif keys == 'logger': # redundant
				pass
			else:
				print(f"* {keys}: {values}")

	def read_config(self, path=None):
		# Just reads the file, doesn't actually set anything in and of itself
		if path is None:
			path = "/Users/aofarrel/github/ranchero/src/config.yaml"
			print("‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏èSTOP USING HARDCODED PATHS FOR YOUR DEFAULTS!!‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è")
		with open(path, 'r') as file:
			config = yaml.safe_load(file)
		typed_config: ConfigParameters = config # doesn't enforce typing in and of itself
		for keys in typed_config:
			assert self.is_in_ConfigParameters(keys)
		return typed_config

	def set_config(self, overrides):
		for option, value in overrides.items():
			# TODO: actually implement this
			#if option not in ConfigParameters:
			#	raise ValueError(f"Option {option!r} doesn't exist")
			setattr(self, option, value)

	def override_config(self, overrides) -> None:
		for option, value in overrides.items():
			if not hasattr(self, option):
				raise ValueError(f"Option {option!r} doesn't exist")
			getattr(self, option)(value)

	def prepare_taxoncore_dictionary(self, tsv='./src/statics/taxoncore_v4.tsv'):
		if os.path.isfile(tsv):
			with open(tsv, 'r') as tsvfile:
				taxoncore_rules = []
				for row in csv.DictReader(tsvfile, delimiter='\t'):
					rule = {
						"when": row["when"],
						#"strain": row["strain"],
						#"lineage": row["lineage"],
						"strain": pl.Null if row["strain"] == "None" else row["strain"],
						"lineage": pl.Null if row["lineage"] == "None" else row["lineage"],
						"organism": row["organism"],
						"group": row["bacterial group"],
						"comment": row["comment"]
					}
					taxoncore_rules.append(rule)
			#with open("./src/statics/generated_taxoncore_dictionary.py", "w") as outfile:
			#	outfile.write(f"# This file is automatically generated by config.py from {tsv}\n")
			#	json.dump(taxoncore_rules, outfile)
			return taxoncore_rules
		else:
			if os.path.isfile("./src/statics/generated_taxoncore_dictionary.py"):
				self.logger.warning("""Found a generated taxoncore dictionary, but not its source TSV.
					We can still use all standardize functions, but be aware the dictionary may be 'stale'.""")
				return taxoncore_rules
			else:
				self.logger.warning(f"""Found neither taxoncore TSV nor generated dictionary at {tsv} 
					(workdir: {os.getcwd()}). Certain functions will not work.""")
				return None

	def _setup_logger(self):
		"""Sets up a logger instance"""
		if not logging.getLogger().hasHandlers(): # necessary to avoid different modules logging all over each other
			logger = logging.getLogger(__name__)
			logging.basicConfig(format='%(levelname)s:%(funcName)s:%(message)s', level=self.loglevel)
		return logger

	#def _setup_tqdm(self):
	#	""" Sets up a TQDM instance"""
	#	tqdm.pandas(ascii='‚ûñüå±üêÑ', bar_format='{desc:<10.9}{percentage:3.0f}%|{bar:12}{r_bar}') # we gotta make it cute!


	def __init__(self):
		""" Creates a fallback configuration if read_config() isn't run"""
		defaults = self.read_config()
		self.set_config(defaults)
		self.logger = self._setup_logger()
		self.taxoncore_ruleset = self.prepare_taxoncore_dictionary()
		#self.print_config_raw()
